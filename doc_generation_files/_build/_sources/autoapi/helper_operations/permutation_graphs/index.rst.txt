helper_operations.permutation_graphs
====================================

.. py:module:: helper_operations.permutation_graphs


Functions
---------

.. autoapisummary::

   helper_operations.permutation_graphs.binomial
   helper_operations.permutation_graphs.multinomial
   helper_operations.permutation_graphs.perm
   helper_operations.permutation_graphs.get_num_of_inversions
   helper_operations.permutation_graphs.count_inversions
   helper_operations.permutation_graphs.defect
   helper_operations.permutation_graphs.swapPair
   helper_operations.permutation_graphs.generate_adj
   helper_operations.permutation_graphs.graph
   helper_operations.permutation_graphs.extend
   helper_operations.permutation_graphs.extend_cycle_cover
   helper_operations.permutation_graphs.shorten
   helper_operations.permutation_graphs.signature
   helper_operations.permutation_graphs.rotate
   helper_operations.permutation_graphs._halveSignature
   helper_operations.permutation_graphs.multiset
   helper_operations.permutation_graphs._permutations
   helper_operations.permutation_graphs._selectOdds
   helper_operations.permutation_graphs.stutterPermutations
   helper_operations.permutation_graphs.nonStutterPermutations
   helper_operations.permutation_graphs._stutterize
   helper_operations.permutation_graphs.selectByTail
   helper_operations.permutation_graphs.HpathQ
   helper_operations.permutation_graphs.HcycleQ
   helper_operations.permutation_graphs.LargeHpathQ
   helper_operations.permutation_graphs.LargeHcycleQ
   helper_operations.permutation_graphs.total_path_motion


Module Contents
---------------

.. py:function:: binomial(k0: int, k1: int) -> int

   Returns binomial coefficient k0+k1 choose k0, which equals k0+k1 choose k1.
   Assumption: 0 <= k0 and 0 <= k1


.. py:function:: multinomial(s: list[int]) -> int

   Returns multinomial coefficient for list s.
   Assumption: all(0 <= k for k in s)


.. py:function:: perm(sig: list[int]) -> list[list[int]]

   Returns all permutations with signature sig
   @param sig: signature as a list of integers
   @return: list of permutations as lists of integers


.. py:function:: get_num_of_inversions(permutation: tuple[int, Ellipsis]) -> int

   Count the number of inversions in a permutation using merge sort
   From https://www.geeksforgeeks.org/inversion-count-in-array-using-merge-sort/
   @param permutation: list of integers
   @return: number of inversions


.. py:function:: count_inversions(sig: list[int]) -> dict[tuple, int]

   Count the number of inversions for all permutations of a signature
   @param sig: signature as a list of integers
   @return: dictionary with permutations as keys and number of inversions as values


.. py:function:: defect(s: list[int]) -> int

   Returns the number of spurs of a given signature according to Lehmer's definition for the defect:
   The number of even permutations - number of odd permutations
   @param s: signature as a list of integers
   @return: absolute difference between the number of even and odd permutations


.. py:function:: swapPair(perm: tuple[int, Ellipsis], i: int, j: int = None) -> tuple[int, Ellipsis]

   Swaps elements in perm at positions i and j (or i and i+1 if j is not provided).
   @param perm: permutation as a tuple of integers
   @param i: first index
   @param j: second index (optional, default is i+1)
   @return: new permutation as a tuple of integers


.. py:function:: generate_adj(p: list[int]) -> list[tuple[int, Ellipsis]]

   Returns all adjacent elements of permutation p
   @param p: list of integers
   @return: list of tuples of integers, the new permutations generated by neighbor-swapping


.. py:function:: graph(sig: list[int]) -> dict[str, set[str]]

   Returns a graph with signature sig in form of dictionary of strings
   @param sig: signature as a list of integers
   @return: dictionary with permutations as keys and adjacent permutations as values


.. py:function:: extend(lst: list[tuple[int, Ellipsis]], e: tuple[int, Ellipsis]) -> list[tuple[int, Ellipsis]]

   Extend every item in l with e
   :param lst: list of tuples
   :param e: tuple to extend every item in l with
   :return:


.. py:function:: extend_cycle_cover(lis3d: list[list[tuple[int, Ellipsis]]], e: tuple[int, Ellipsis]) -> list[list[tuple[int, Ellipsis]]]

   Extend every item in a list of unknown depth holding a list of permutations with e
   :param lst: list of unknown depth with list of tuples
   :param e: tuple to extend every item in l with
   :return:


.. py:function:: shorten(lis: list[tuple[int, Ellipsis]], num: int) -> list[tuple[int, Ellipsis]]

   Shorten every item in l by num elements from the end
   @param lis: list of permutations
   @param num: number of elements to remove from the back
   @return: list of shortened permutations


.. py:function:: signature(permutation: tuple[int, Ellipsis]) -> list[int]

   Returns signature of a permutation.
   @param permutation: permutation as a tuple of integers
   @return: signature as a list of integers


.. py:function:: rotate(l: list, n: int) -> list

   Rotates the list l by n positions to the left
   @param l: list to rotate
   @param n: number of positions to rotate


.. py:function:: _halveSignature(sig: list[int]) -> list[int]

   Halves the signature. ([2, 4, 6] --> [1, 2, 3]), rounding down.
   @param sig: signature as a list of integers
   @return: halved signature as a list of integers


.. py:function:: multiset(s: list[int]) -> tuple[int, Ellipsis]

   Generates the lexicographically smallest list with given signature.
   @param s: list of integers, each representing the frequency of the corresponding element (signature)
   @return: lexicographically smallest permutation with the given signature


.. py:function:: _permutations(s: list[int]) -> list[tuple[int, Ellipsis]]

   Generates all possible permutations of a given list of integers.
   @param s: list of integers, the signature
   @return: list of permutations as tuples of integers


.. py:function:: _selectOdds(sig: tuple[int, Ellipsis]) -> tuple[int, Ellipsis]

   Returns list of numbers with odd occurrence frequencies in the given signature.
   @param sig: signature as a tuple of integers
   @return: tuple of integers with odd occurrence frequencies


.. py:function:: stutterPermutations(s: list[int]) -> list[tuple[int, Ellipsis]]

   Generates stutter permutations of a given signature.
   @param s: signature of the permutations as a list of integers
   @return: stutter permutations as a list of tuples of integers


.. py:function:: nonStutterPermutations(s: list[int]) -> list[tuple[int, Ellipsis]]

   Returns all non-stutter permutations of signature sig
   @param sig: signature of the permutations as a list of integers
   @return: non-stutter permutations as a list of tuples of integers


.. py:function:: _stutterize(p_list: list[tuple[int, Ellipsis]]) -> list[tuple[int, Ellipsis]]

   Converts a list of permutations into stutter permutation by repeating every number twice
   @param p: a list of permutations as a list of tuples of integers
   @return: all stutter permutations as a list of tuples of integers


.. py:function:: selectByTail(permutations: list[tuple[int, Ellipsis]], tail: tuple[int, Ellipsis]) -> list[tuple[int, Ellipsis]]

   Select permutations with a given tail 'tail'
   @param s: list of permutations
   @param tail: elements of the tail to select
   @return: list of permutations with the given tail


.. py:function:: HpathQ(per: list[tuple[int, Ellipsis]], sig: list[int]) -> bool

   Determines whether the path is a Hamiltonian path on the non-stutter permutations of the given signature.
   @param per: list of permutations ordered in a path
   @param sig: signature as a list of integers


.. py:function:: HcycleQ(per: list[tuple[int, Ellipsis]], sig: list[int]) -> bool

   Determines whether the list of permutations is a Hamiltonian cycle on the non-stutter permutations of the given signature.
   @param per: list of permutations, ordered in a cycle
   @param sig: signature as a list of integers


.. py:function:: LargeHpathQ(per: list[tuple[int, Ellipsis]], sig: list[int]) -> bool

   Determines whether the path is a Hamiltonian path on the non-stutter permutations of the given signature.
   @param per: list of permutations, ordered in a path
   @param sig: signature as a list of integers


.. py:function:: LargeHcycleQ(per: list[tuple[int, Ellipsis]], sig: list[int]) -> bool

   Determines whether the path is a Hamiltonian cycle on the non-stutter permutations of the given signature.
   @param per: list of permutations, ordered in a cycle
   @param sig: signature as a list of integers


.. py:function:: total_path_motion(path: list[tuple[int, Ellipsis]]) -> int

   Returns the sum of the transposition widths (difference in index between the two transposed elements) for all nodes in the path
   @param path: list of permutations
   @return: total motion as an integer


