<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>type_variations.stachowiak_numpy &mdash; Lehmer Paths in Neighbor-Swap Graphs  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Lehmer Paths in Neighbor-Swap Graphs
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Lehmer Paths in Neighbor-Swap Graphs</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">type_variations.stachowiak_numpy</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for type_variations.stachowiak_numpy</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">helper_operations.path_operations</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">adjacent</span><span class="p">,</span>
    <span class="n">cutCycle</span><span class="p">,</span>
    <span class="n">cycleQ</span><span class="p">,</span>
    <span class="n">pathQ</span><span class="p">,</span>
    <span class="n">transform</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">type_variations.steinhaus_johnson_trotter_numpy</span> <span class="kn">import</span> <span class="n">SteinhausJohnsonTrotterNumpy</span>
<span class="kn">from</span> <span class="nn">type_variations.verhoeff_numpy</span> <span class="kn">import</span> <span class="n">HpathNS</span>


<div class="viewcode-block" id="split_path_in_2">
<a class="viewcode-back" href="../../autoapi/type_variations/stachowiak_numpy/index.html#type_variations.stachowiak_numpy.split_path_in_2">[docs]</a>
<span class="k">def</span> <span class="nf">split_path_in_2</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split a path array into two parts based on a given value.</span>

<span class="sd">    Args:</span>
<span class="sd">        p (np.ndarray): The path array to be split.</span>
<span class="sd">        a (np.array): The value used to split the path array.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[np.ndarray, np.ndarray]:</span>
<span class="sd">            A tuple containing two arrays:\n</span>
<span class="sd">            - The first array contains the elements of the path array up to and including the first occurrence of the given value.</span>
<span class="sd">            - The second array contains the elements of the path array after the first occurrence of the given value.</span>

<span class="sd">    Raises:</span>
<span class="sd">        AssertionError: If the length of the path array is less than or equal to 1.</span>
<span class="sd">        AssertionError: If `a` is not in `p`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
    <span class="c1"># find the index of the first occurrence of the given value</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">p</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[:</span> <span class="n">A</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="n">A</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span></div>



<div class="viewcode-block" id="_generate_all_di">
<a class="viewcode-back" href="../../autoapi/type_variations/stachowiak_numpy/index.html#type_variations.stachowiak_numpy._generate_all_di">[docs]</a>
<span class="k">def</span> <span class="nf">_generate_all_di</span><span class="p">(</span><span class="n">chain_p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate all possible `d_i` chains based on the given `chain_p`.</span>
<span class="sd">    This function corresponds to the start of the proof of Lemma 2 (case 2.1 if the length of `chain_p` even).</span>

<span class="sd">    Args:</span>
<span class="sd">        chain_p (tuple[int, ...]): The chain of `p` elements in the lemma.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[tuple[int, ...]]:</span>
<span class="sd">            All possible `d_i` chains. Each `d_i` chain is represented as a numpy array of numpy arrays with integers:</span>
<span class="sd">            `d_i=[0l^{p-i} 1 l^i, l0l^{p-i-1} 1 l^i, \cdots, l^{p-i} 01 l^i, l^{p-i} 10 l^i, \cdots, 1 l^{p-i} 0 l^i]`.</span>
<span class="sd">            This is for every `0 &lt;= i &lt;= p`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">d_all</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chain_p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">d_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain_p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chain_p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span><span class="p">):</span>
            <span class="n">d_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">d_i</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">chain_p</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">chain_p</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="p">:],</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">chain_p</span><span class="p">[:</span><span class="n">j</span><span class="p">]),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chain_p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span><span class="p">)):</span>
            <span class="n">d_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">d_i</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">chain_p</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">chain_p</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="p">:],</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">chain_p</span><span class="p">[:</span><span class="n">j</span><span class="p">]),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">d_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d_i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">d_all</span>
        <span class="p">],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="_generate_all_di_prime">
<a class="viewcode-back" href="../../autoapi/type_variations/stachowiak_numpy/index.html#type_variations.stachowiak_numpy._generate_all_di_prime">[docs]</a>
<span class="k">def</span> <span class="nf">_generate_all_di_prime</span><span class="p">(</span><span class="n">chain_p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate all possible `d_i` chains based on the given `chain_p`.</span>
<span class="sd">    This function corresponds to the start of the proof of Lemma 2 (case 2.2 if the length of `chain_p` even).</span>

<span class="sd">    Args:</span>
<span class="sd">        chain_p (tuple[int, ...]): The chain of p elements in Lemma 2.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray:</span>
<span class="sd">            All possible `d_i&#39;` chains. Each `d_i&#39;` chain is represented as a numpy array of numpy arrays with integers:</span>
<span class="sd">            `d_i&#39;=[l^i 1 l^{p-i} 0, l^i 1 l^{p-i-1} 0 l, \cdots, l^{i} 10 l^{p-i}, l^i 01 l^{p-i}, \cdots, l^i 0 l^{p-i} 1]`.</span>
<span class="sd">            This is for every `0 &lt;= i &lt;= p`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">d_all</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chain_p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">d_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain_p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chain_p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span><span class="p">):</span>
            <span class="n">d_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">d_i</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">chain_p</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">chain_p</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="p">:],</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">chain_p</span><span class="p">[:</span><span class="n">j</span><span class="p">]),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chain_p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span><span class="p">)):</span>
            <span class="n">d_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">d_i</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">chain_p</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">chain_p</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="p">:],</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">chain_p</span><span class="p">[:</span><span class="n">j</span><span class="p">]),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">d_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d_i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">d_all</span>
        <span class="p">],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="lemma2_cycle">
<a class="viewcode-back" href="../../autoapi/type_variations/stachowiak_numpy/index.html#type_variations.stachowiak_numpy.lemma2_cycle">[docs]</a>
<span class="k">def</span> <span class="nf">lemma2_cycle</span><span class="p">(</span><span class="n">chain_p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">case_2_1</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function generates the cycles of Lemma 2.</span>
<span class="sd">    If the length of the `chain_p` is even the last two nodes are discarded as in the lemma.</span>
<span class="sd">    Defaults to case 2.1 of Lemma 2. If the `case_2_1` variable is set to `False`, the cycle will be as in case 2.2. The discarded nodes are:\n</span>
<span class="sd">    - `d_p = (01 l^p, 10 l^p)` for case 2.1</span>
<span class="sd">    - `d_p&#39; = (l^p 01, l^p 10)` for case 2.2</span>

<span class="sd">    Args:</span>
<span class="sd">        chain_p (np.array): The chain of p elements in the lemma</span>
<span class="sd">        case_2_1 (bool, optional):</span>
<span class="sd">            Whether the case is 2.1 or 2.2. Defaults to `True`.\n</span>
<span class="sd">            - `True` ==&gt; Case 2.1 with all `d_i` paths.</span>
<span class="sd">            - `False` ==&gt; Case 2.2 with all `d_i&#39;` paths.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray:</span>
<span class="sd">            The cycle of all `d_i` or `d_i&#39;` paths.</span>
<span class="sd">            If the length of `chain_p` is even, `d_p` or `d_p&#39;` is discarded respectively to the input for `case_2_1`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">case_2_1</span><span class="p">:</span>
        <span class="n">d_all</span> <span class="o">=</span> <span class="n">_generate_all_di</span><span class="p">(</span><span class="n">chain_p</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d_all</span> <span class="o">=</span> <span class="n">_generate_all_di_prime</span><span class="p">(</span><span class="n">chain_p</span><span class="p">)</span>
    <span class="c1"># chain_1_1_path, last_elements = [], []</span>
    <span class="n">chain_1_1_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain_p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">last_elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain_p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">d_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">d_all</span><span class="p">):</span>
        <span class="c1"># in case the |P| is even, don&#39;t add the elements 01l^p and 10l^p or l^p01 and l^p10 respectively to case 2.1 or 2.2</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_all</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_all</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="c1"># never add the last elements, those will be added at the end to create a cycle</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># add the reversed list without the last element</span>
            <span class="n">chain_1_1_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">chain_1_1_path</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">d_i</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chain_1_1_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">chain_1_1_path</span><span class="p">,</span> <span class="n">d_i</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># keep track of the last elements</span>
        <span class="n">last_elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">last_elements</span><span class="p">,</span> <span class="p">[</span><span class="n">d_i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
    <span class="c1"># add the last elements of every d_i to complete the cycle</span>
    <span class="n">cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">last_elements</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">chain_1_1_path</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cycle</span></div>



<div class="viewcode-block" id="lemma2_extended_path">
<a class="viewcode-back" href="../../autoapi/type_variations/stachowiak_numpy/index.html#type_variations.stachowiak_numpy.lemma2_extended_path">[docs]</a>
<span class="k">def</span> <span class="nf">lemma2_extended_path</span><span class="p">(</span><span class="n">chain_p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">case_2_1</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extends the cycle of Lemma 2 with the last two elements in case `chain_p` is even.</span>
<span class="sd">    If the length of `chain_p` is odd, then the cycle is returned.</span>
<span class="sd">    Defaults to case 2.1 of Lemma 2. If the `case_2_1` variable is set to `False`, the path will be as in case 2.2.\r\n</span>
<span class="sd">    If `chain_p` is even, the two nodes which are appended to the path are;\n</span>
<span class="sd">    - `d_p = (01 l^p, 10 l^p)` for case 2.1</span>
<span class="sd">    - `d_p&#39; = (l^p 01, l^p 10)` for case 2.2</span>

<span class="sd">    Args:</span>
<span class="sd">        chain_p (np.array): The chain of p elements in the lemma.</span>
<span class="sd">        case_2_1 (bool, optional):</span>
<span class="sd">            Whether the case is 2.1 or 2.2. Defaults to `True`.\n</span>
<span class="sd">            - `True` ==&gt; Case 2.1 with all `d_i` chains.</span>
<span class="sd">            - `False` ==&gt; Case 2.2 with all `d_i&#39;` chains.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray:</span>
<span class="sd">            The cycle of all `d_i` or `d_i&#39;` chains extended with the two nodes that are left out if the length of `chain_p` is even.\n</span>
<span class="sd">            - `d_i=[0l^{p-i} 1 l^i, l0l^{p-i-1} 1 l^i, \cdots, l^{p-i} 01 l^i, l^{p-i} 10 l^i, \cdots, 1 l^{p-i} 0 l^i]`</span>
<span class="sd">            - `d_i&#39;=[l^i 1 l^{p-i} 0, l^i 1 l^{p-i-1} 0 l, \cdots, l^{i} 10 l^{p-i}, l^i 01 l^{p-i}, \cdots, l^i 0 l^{p-i} 1]`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cycle</span> <span class="o">=</span> <span class="n">lemma2_cycle</span><span class="p">(</span><span class="n">chain_p</span><span class="p">,</span> <span class="n">case_2_1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain_p</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">case_2_1</span><span class="p">:</span>
            <span class="n">pre_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">chain_p</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">chain_p</span><span class="p">))],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pre_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">chain_p</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">chain_p</span><span class="p">))],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">pre_path</span><span class="p">,</span> <span class="n">cycle</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">pathQ</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span>
    <span class="k">return</span> <span class="n">cycle</span></div>



<div class="viewcode-block" id="_lemma8_helper">
<a class="viewcode-back" href="../../autoapi/type_variations/stachowiak_numpy/index.html#type_variations.stachowiak_numpy._lemma8_helper">[docs]</a>
<span class="k">def</span> <span class="nf">_lemma8_helper</span><span class="p">(</span><span class="n">sig_occ</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function for Lemma 8 of Stachowiak:</span>
<span class="sd">    The graph `G=GE( (char_0|char_1) (k^q|l^p) )` contains a Hamilton cycle for every `p, q &gt; 0`.</span>
<span class="sd">    `k^q` is a chain of q elements &quot;k&quot;, `l^p` is a chain of p elements &quot;l&quot;.</span>
<span class="sd">    We say the first element is `char_0` and the second element is `char_1`.</span>

<span class="sd">    Args:</span>
<span class="sd">        sig_occ (np.ndarray):</span>
<span class="sd">            The signature of the neighbor-swap graph; `[1, 1, q, p]`.</span>
<span class="sd">            It has the form `[(int, 1), (int, 1), (int, q), (int, p)]`.</span>
<span class="sd">            The first two integers are of different colors and occur once.</span>
<span class="sd">            The last two integers are of different colors and can occur any number of times &gt;= 0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[np.ndarray, np.ndarray]:</span>
<span class="sd">            A Hamiltonian cycle of the form `(char_0|char_1) (k^q|l^p)`.</span>
<span class="sd">            So the first two elements are always before the last two elements but their internal order can differ.</span>

<span class="sd">    Raises:</span>
<span class="sd">        AssertionError: If the first two elements do not occur once.</span>
<span class="sd">        AssertionError: If the first two elements are not of different colors.</span>
<span class="sd">        AssertionError: If the last two elements are not of different colors.</span>
<span class="sd">        AssertionError: If the last two elements occur less than 0 times.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">first_char</span> <span class="o">=</span> <span class="n">sig_occ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">second_char</span> <span class="o">=</span> <span class="n">sig_occ</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">sig_occ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">sig_occ</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">first_char</span> <span class="o">!=</span> <span class="n">second_char</span>
    <span class="k">assert</span> <span class="n">sig_occ</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">sig_occ</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">k_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">sig_occ</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">sig_occ</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">l_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">sig_occ</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">sig_occ</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">sig_occ</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">first_char</span><span class="p">,</span> <span class="n">second_char</span><span class="p">]),</span> <span class="p">(</span><span class="n">sig_occ</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">second_char</span><span class="p">,</span> <span class="n">first_char</span><span class="p">]),</span> <span class="p">(</span><span class="n">sig_occ</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">cycle1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">k_q</span><span class="p">,</span> <span class="n">l_p</span><span class="p">)))),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">cycle2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">k_q</span><span class="p">,</span> <span class="n">l_p</span><span class="p">)))),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sig_occ</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">cycle1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">(</span><span class="n">cycle1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">k_q</span><span class="p">[</span><span class="n">index</span><span class="p">:],</span> <span class="n">l_p</span><span class="p">,</span> <span class="n">k_q</span><span class="p">[:</span><span class="n">index</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">cycle2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">(</span><span class="n">cycle2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">k_q</span><span class="p">[:</span><span class="n">index</span><span class="p">],</span> <span class="n">l_p</span><span class="p">,</span> <span class="n">k_q</span><span class="p">[</span><span class="n">index</span><span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="n">cycle1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">cycle1</span><span class="p">,</span> <span class="n">cycle2</span><span class="p">))</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">q</span><span class="p">,</span> <span class="n">q2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">q</span><span class="p">,</span> <span class="n">cycle1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">all_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">end_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k_q</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">end_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k_q</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">sig_occ</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">q</span><span class="p">,</span> <span class="n">g_i</span> <span class="o">=</span> <span class="n">_lemma8_helper</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">sig_occ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]))</span>
            <span class="p">)</span>
            <span class="n">ge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">g_i</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">g_i</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">k_q</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="p">[</span><span class="n">l_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">suffix</span><span class="p">))</span>
                <span class="n">ge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ge</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="n">sig_occ</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">all_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">all_q</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">result</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">ge</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">all_q</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">result</span><span class="p">,</span> <span class="n">ge</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">end_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">end_q</span><span class="p">,</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">end_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">end_res</span><span class="p">,</span> <span class="p">[</span><span class="n">ge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">all_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">all_q</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">end_q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">result</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">end_res</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">all_q</span><span class="p">,</span> <span class="n">result</span></div>



<div class="viewcode-block" id="_lemma7_constructor">
<a class="viewcode-back" href="../../autoapi/type_variations/stachowiak_numpy/index.html#type_variations.stachowiak_numpy._lemma7_constructor">[docs]</a>
<span class="k">def</span> <span class="nf">_lemma7_constructor</span><span class="p">(</span><span class="n">sig</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Writes colors of Lemma 7 to fit the helper of Lemma 8 (which solves a more general version of this graph).</span>
<span class="sd">    Lemma 7 by Stachowiak is: The graph `G=GE( (0|1) (k^q|l^p) )` contains a Hamilton cycle for every `p, q &gt; 0`</span>

<span class="sd">    Parameters:</span>
<span class="sd">        sig (np.array):</span>
<span class="sd">            The signature of the graph in the form `[1, 1, q, p]`.</span>
<span class="sd">            The elements are of colors 0, 1, 2, 3 (so color 2 occurs `q` times and 3 occurs `p` times).</span>
<span class="sd">            Colors 0 and 1 occur once, colors 2 and 3 occur q and p times respectively.</span>
<span class="sd">            The first two elements are of different colors and the last two elements are of different colors than each other.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[np.ndarray, np.ndarray]:</span>
<span class="sd">            A tuple of the q set and the suffix.\n</span>
<span class="sd">            - The q set is the 01 or 10 part, i.e. the first two nodes of the permutations.</span>
<span class="sd">            - The suffix set is the k^q and the l^p part permuted, i.e. the rest of the permutation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_lemma8_helper</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">sig</span><span class="p">[</span><span class="mi">3</span><span class="p">]]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="lemma7">
<a class="viewcode-back" href="../../autoapi/type_variations/stachowiak_numpy/index.html#type_variations.stachowiak_numpy.lemma7">[docs]</a>
<span class="k">def</span> <span class="nf">lemma7</span><span class="p">(</span><span class="n">sig</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes Lemma 7 by Stachowiak: The graph `G=GE( (0|1) (k^q|l^p) )` contains a Hamilton cycle for every `p, q &gt; 0`.</span>

<span class="sd">    Args:</span>
<span class="sd">        sig (np.array):</span>
<span class="sd">            The signature of the graph in the form `[1, 1, q, p]`.</span>
<span class="sd">            The elements are of colors 0, 1, 2, 3 (so color 2 occurs `q` times and 3 occurs `p` times).</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: A Hamiltonian cycle of the form `(0|1) (k^q|l^p)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span><span class="p">,</span> <span class="n">suffix</span> <span class="o">=</span> <span class="n">_lemma7_constructor</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="n">cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">suffix</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">))])</span>
    <span class="k">return</span> <span class="n">cycle</span></div>



<div class="viewcode-block" id="_cut_cycle_start_end">
<a class="viewcode-back" href="../../autoapi/type_variations/stachowiak_numpy/index.html#type_variations.stachowiak_numpy._cut_cycle_start_end">[docs]</a>
<span class="k">def</span> <span class="nf">_cut_cycle_start_end</span><span class="p">(</span><span class="n">cyc</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes sure `x` is the start node of a given cycle `cyc` and `y` is the end node.</span>

<span class="sd">    Args:</span>
<span class="sd">        cyc (np.ndarray): Cycle in a subgraph.</span>
<span class="sd">        x (np.array): Node that should be at the start of the path.</span>
<span class="sd">        y (np.array): Node that should be at the end of the path.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Subgraph with `x` as start and `y` as end.</span>

<span class="sd">    Raises:</span>
<span class="sd">        AssertionError: If `x` and `y` are not adjacent.</span>
<span class="sd">        AssertionError: If `cyc` is not a cycle.</span>
<span class="sd">        AssertionError: If `x` or `y` is not in the cycle.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">adjacent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="si">}</span><span class="s2"> not adjacent for x: </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">, y: </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">err</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">cycleQ</span><span class="p">(</span><span class="n">cyc</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="si">}</span><span class="s2"> in &#39;cycle-cut-start-end&#39; not a cycle: </span><span class="si">{</span><span class="n">cyc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">err</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cyc</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">cyc</span>
    <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="si">}</span><span class="s2"> for x: </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">, y: </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">, not in cycle: </span><span class="si">{</span><span class="n">cyc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">err</span>
    <span class="n">cyc_cut</span> <span class="o">=</span> <span class="n">cutCycle</span><span class="p">(</span><span class="n">cyc</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">cyc_cut</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">cyc_cut</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">cyc_cut</span><span class="p">[:</span><span class="mi">1</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">cycleQ</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">return</span> <span class="n">cyc_cut</span></div>



<div class="viewcode-block" id="_lemma8_g_i_sub_graphs">
<a class="viewcode-back" href="../../autoapi/type_variations/stachowiak_numpy/index.html#type_variations.stachowiak_numpy._lemma8_g_i_sub_graphs">[docs]</a>
<span class="k">def</span> <span class="nf">_lemma8_g_i_sub_graphs</span><span class="p">(</span><span class="n">k_q</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">l_p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">sig</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates the G_i sub graphs of Lemma 8 by making the G_ij sub graphs and connecting them as in the lemma.</span>
<span class="sd">    G_{ij} is one of three cases:\n</span>
<span class="sd">    - G_{ij} = GE( l^(2j) (0 | l) l^(p-i-2j-1) 1(l^i | k^q) )           for 0 &lt;= j &lt; (p-i)/2\n</span>
<span class="sd">    - G_{ij} = GE( l^(p-i) (0 | 1) (l^i | k^q) )                        for j = (p-i)/2\n</span>
<span class="sd">    - G_{ij} = GE( l^(2(p-i-j)) (l | 1) l^(i+2j-p-1) 0(l^i | k^q) )     for (p-i)/2 &lt; j &lt;= p-i\r\n</span>
<span class="sd">    These subgraphs are connected by nodes y_{ij}, x_{i(j+1)} for different x_ij:\n</span>
<span class="sd">    - x_{ij} = l^(2j) 0 l^(p-i-2j) 1 l^i k^q for 0 &lt;= j &lt; (p-i)/2\n</span>
<span class="sd">    - x_{ij} = l^(p-i) 0 1 l^i k^q for j = (p-i)/2\n</span>
<span class="sd">    - x_{ij} = l^(2(p-i-j)+1) 1 l^(i+2j-p-1) l^i k^q for (p-i)/2 &lt; j &lt;= p-i\r\n</span>
<span class="sd">    And y_{ij}:\n</span>
<span class="sd">    - y_{ij} = l^(2j+1) 0 l^(p-i-2j-1) 1 l^i k^q for 0 &lt;= j &lt; (p-i)/2\n</span>
<span class="sd">    - y_{ij} = l^(p-i) 1 0 l^i k^q for j = (p-i)/2\n</span>
<span class="sd">    - y_{ij} = l^(2(p-i-j)) 1 l^(i+2j-p) l^i k^q for (p-i)/2 &lt; j &lt;= p-i\n</span>

<span class="sd">    Args:</span>
<span class="sd">        k_q (np.array): Chain of q elements &quot;k&quot;</span>
<span class="sd">        l_p (np.array): Chain of p element &quot;l&quot;</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray:</span>
<span class="sd">            List of `G_i` sub graphs: `G_i = G( (0 | l^(p-i) 1(k^q | l^i)), (1 | l^(p-i) 0(k^q | l^i)) )`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g_all</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">g_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sig</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">g_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sig</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># 0 &lt;= j &lt; (p-i)/2</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">l7_q_set</span><span class="p">,</span> <span class="n">l7_suffix</span> <span class="o">=</span> <span class="n">_lemma8_helper</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k_q</span><span class="p">)),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">l7_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l7_q_set</span><span class="p">)):</span>
                    <span class="n">g_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">g_ij</span><span class="p">,</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                                <span class="p">[</span>
                                    <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span><span class="p">],</span>
                                    <span class="o">*</span><span class="n">l7_q_set</span><span class="p">[</span><span class="n">l7_i</span><span class="p">],</span>
                                    <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                                    <span class="mi">1</span><span class="p">,</span>
                                    <span class="o">*</span><span class="n">l7_suffix</span><span class="p">[</span><span class="n">l7_i</span><span class="p">],</span>
                                <span class="p">]</span>
                            <span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">x_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="o">*</span><span class="n">l_p</span><span class="p">[:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">k_q</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">y_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="mi">0</span><span class="p">,</span>
                        <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="mi">1</span><span class="p">,</span>
                        <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span>
                        <span class="o">*</span><span class="n">k_q</span><span class="p">,</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="c1"># j == (p-i)/2</span>
            <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">l7_subgraph</span> <span class="o">=</span> <span class="n">lemma7</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k_q</span><span class="p">),</span> <span class="n">i</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">l7_subgraph</span><span class="p">:</span>
                    <span class="n">g_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">g_ij</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">l_p</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">item</span><span class="p">])))</span>
                <span class="n">x_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">l_p</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">k_q</span><span class="p">])</span>
                <span class="n">y_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">l_p</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">k_q</span><span class="p">])</span>
            <span class="c1"># (p-i)/2 &lt; j &lt;= p-i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l7_q_set</span><span class="p">,</span> <span class="n">l7_suffix</span> <span class="o">=</span> <span class="n">_lemma8_helper</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">l7_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l7_q_set</span><span class="p">)):</span>
                    <span class="n">g_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">g_ij</span><span class="p">,</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                                <span class="p">[</span>
                                    <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">)],</span>
                                    <span class="o">*</span><span class="n">l7_q_set</span><span class="p">[</span><span class="n">l7_i</span><span class="p">],</span>
                                    <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                                    <span class="mi">0</span><span class="p">,</span>
                                    <span class="o">*</span><span class="n">l7_suffix</span><span class="p">[</span><span class="n">l7_i</span><span class="p">],</span>
                                <span class="p">]</span>
                            <span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">x_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="mi">1</span><span class="p">,</span>
                        <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="mi">0</span><span class="p">,</span>
                        <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span>
                        <span class="o">*</span><span class="n">k_q</span><span class="p">,</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="n">y_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">)],</span>
                        <span class="mi">1</span><span class="p">,</span>
                        <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)],</span>
                        <span class="mi">0</span><span class="p">,</span>
                        <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span>
                        <span class="o">*</span><span class="n">k_q</span><span class="p">,</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="n">g_ij</span> <span class="o">=</span> <span class="n">_cut_cycle_start_end</span><span class="p">(</span><span class="n">g_ij</span><span class="p">,</span> <span class="n">x_ij</span><span class="p">,</span> <span class="n">y_ij</span><span class="p">)</span>
            <span class="n">g_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">g_i</span><span class="p">,</span> <span class="n">g_ij</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span>
            <span class="n">g_i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">l_p</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">k_q</span><span class="p">])</span>
        <span class="p">):</span>
            <span class="n">g_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g_i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">((</span><span class="n">g_i</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g_all</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></div>



<div class="viewcode-block" id="_lemma9_glue_a_edges">
<a class="viewcode-back" href="../../autoapi/type_variations/stachowiak_numpy/index.html#type_variations.stachowiak_numpy._lemma9_glue_a_edges">[docs]</a>
<span class="k">def</span> <span class="nf">_lemma9_glue_a_edges</span><span class="p">(</span>
    <span class="n">k_r</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">k_s</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">l_p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">sub_cycles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Glues the a_i edges from Lemma 8 by Stachowiak together to create the final cycle.</span>
<span class="sd">    `a_i = ( 0 l^(p-i) 1 l^i k^q, 0 l^(p-i) 1 l^(i-1) k l k^q )`</span>

<span class="sd">    Args:</span>
<span class="sd">        k_r (np.array): Chain of r elements &quot;k&quot;</span>
<span class="sd">        k_s (np.array): Chain of s elements &quot;k&quot; (so  the same element as k_r but maybe a different length)</span>
<span class="sd">        l_p (np.array): Chain of p elements &quot;l&quot; (different from k_r and k_s)</span>
<span class="sd">        sub_cycles (np.ndarray): Sub cycles created by gluing y_{ij}, x_{i(j+1)} from Lemma 8</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray:</span>
<span class="sd">            Cycle of all sub cycles glued together. Has the form `GE( (k^r (0|1) k^s) | l^p) )`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make the a1 path, we have as first part of the cycle a11~path~a12</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sub_cycles</span>
    <span class="n">p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k_s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">g_result_start</span> <span class="o">=</span> <span class="n">_cut_cycle_start_end</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sub_cycles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">k_r</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="n">l_p</span><span class="p">[:</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k_s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
                    <span class="n">k_s</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                <span class="p">)</span>
            <span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="n">k_r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">l_p</span><span class="p">[:</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">l_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">k_s</span><span class="p">)</span>
            <span class="p">),</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">g_result_start</span> <span class="o">=</span> <span class="n">_cut_cycle_start_end</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sub_cycles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="n">l_p</span><span class="p">[:</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k_r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
                    <span class="n">k_r</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                <span class="p">)</span>
            <span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">l_p</span><span class="p">[:</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">l_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">k_r</span><span class="p">)),</span>
        <span class="p">)</span>
    <span class="n">g_result_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k_r</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">k_s</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># for each of the floor((p+1)/2) sub cycles</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_cycles</span><span class="p">)</span> <span class="o">-</span> <span class="p">((</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)):</span>
        <span class="c1"># take the first a1 and a2 and make them into a cycle from a1 ~ all nodes in cycle ~ a2</span>
        <span class="n">a_2i_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span><span class="n">k_r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">l_p</span><span class="p">[:</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span> <span class="n">l_p</span><span class="p">[:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span> <span class="n">k_s</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">a_2i_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">k_r</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span>
                <span class="n">l_p</span><span class="p">[:</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span>
                <span class="n">l_p</span><span class="p">[:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k_s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
                <span class="n">k_s</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
            <span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">cyc</span> <span class="o">=</span> <span class="n">_cut_cycle_start_end</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sub_cycles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">a_2i_1</span><span class="p">,</span> <span class="n">a_2i_2</span><span class="p">)</span>
        <span class="c1"># then cut that cycle in 2 by splitting after the next a1 (and thus before the next a2)</span>
        <span class="n">next_a_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">k_r</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span>
                <span class="n">l_p</span><span class="p">[:</span> <span class="nb">max</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">)],</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span>
                <span class="n">l_p</span><span class="p">[:</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">k_s</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">split_path_in_2</span><span class="p">(</span><span class="n">cyc</span><span class="p">,</span> <span class="n">next_a_2</span><span class="p">)</span>
        <span class="n">g_result_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">g_result_start</span><span class="p">,</span> <span class="n">p1</span><span class="p">))</span>
        <span class="n">g_result_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">g_result_end</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># if p is even, we are still missing the last cycle which we only have to sort from the last a1~nodes~a2</span>
        <span class="n">a_last_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">k_r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">l_p</span><span class="p">,</span> <span class="n">k_s</span><span class="p">))</span>
        <span class="n">a_last_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span><span class="n">k_r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">l_p</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k_s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l_p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">k_s</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="p">)</span>
        <span class="n">g_result_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span><span class="n">g_result_start</span><span class="p">,</span> <span class="n">_cut_cycle_start_end</span><span class="p">(</span><span class="n">sub_cycles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">a_last_1</span><span class="p">,</span> <span class="n">a_last_2</span><span class="p">))</span>
        <span class="p">)</span>
    <span class="n">g_result_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">g_result_start</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">g_result_end</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">g_result_start</span></div>



<div class="viewcode-block" id="lemma8">
<a class="viewcode-back" href="../../autoapi/type_variations/stachowiak_numpy/index.html#type_variations.stachowiak_numpy.lemma8">[docs]</a>
<span class="k">def</span> <span class="nf">lemma8</span><span class="p">(</span><span class="n">sig</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The graph `G=GE( ((0|1) k^q) | l^p) )` contains a Hamilton cycle for every `p, q &gt; 0`</span>

<span class="sd">    Args:</span>
<span class="sd">        sig (np.array):</span>
<span class="sd">            The signature of the neighbor-swap graph; 1, 1, q, p.</span>
<span class="sd">            We assume the first two elements are of colors 0 and 1 and occur once.</span>
<span class="sd">            The second two elements are of colors 2 and 3 and occur q and p times respectively.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: A Hamiltonian cycle of the form `GE((0|1) k^q) | l^p)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">l_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">g_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sig</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">g_0_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sig</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">g_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">g_0</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">l_p</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">l_p</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span> <span class="n">k_q</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">g_0_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">g_0_end</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">l_p</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span> <span class="n">l_p</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">k_q</span><span class="p">),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="c1"># append g0end to g0</span>
    <span class="n">g_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">g_0</span><span class="p">,</span> <span class="n">g_0_end</span><span class="p">))</span>
    <span class="c1"># only append lemma 8 subgraphs if p &gt; 0</span>
    <span class="k">if</span> <span class="n">sig</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">g_0</span>
    <span class="n">lemma8_sub_graphs</span> <span class="o">=</span> <span class="n">_lemma8_g_i_sub_graphs</span><span class="p">(</span><span class="n">k_q</span><span class="p">,</span> <span class="n">l_p</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
    <span class="n">g_all</span> <span class="o">=</span> <span class="p">[</span><span class="n">g_0</span><span class="p">]</span>
    <span class="n">g_all</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lemma8_sub_graphs</span><span class="p">)</span>

    <span class="n">sub_cycles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">g_all</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">g_all</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span>
    <span class="p">)</span>
    <span class="n">sub_cycles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">sub_cycles</span>
        <span class="p">],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">g_all</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g_all</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">new_cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">g_all</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">g_all</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sub_cycles</span><span class="p">)</span>
        <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_cycle</span><span class="p">)</span>
        <span class="n">sub_cycles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g_all</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sub_cycles</span><span class="p">)</span>
        <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g_all</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">sub_cycles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">sub_cycles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">sublist</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">sub_cycles</span><span class="p">],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">g_result_start</span> <span class="o">=</span> <span class="n">_lemma9_glue_a_edges</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">k_q</span><span class="p">,</span> <span class="n">l_p</span><span class="p">,</span> <span class="n">sub_cycles</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g_result_start</span></div>



<div class="viewcode-block" id="lemma9">
<a class="viewcode-back" href="../../autoapi/type_variations/stachowiak_numpy/index.html#type_variations.stachowiak_numpy.lemma9">[docs]</a>
<span class="k">def</span> <span class="nf">lemma9</span><span class="p">(</span><span class="n">sig</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The graph `G=GE( (k^r (0|1) k^s) | l^p) )` contains a Hamilton cycle for every `p, r+s &gt; 0`.</span>

<span class="sd">    Args:</span>
<span class="sd">        sig (np.array):</span>
<span class="sd">            The signature of the neighbor-swap graph; [1, 1, r, s, p]. We assume:\n</span>
<span class="sd">            - The first two elements are of colors 0 and 1 respectively and occur once.</span>
<span class="sd">            - The second two elements are of color 2 and occur r and s times respectively.</span>
<span class="sd">            - The fourth element is of color 3 and occurs p times.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray:</span>
<span class="sd">            A Hamiltonian cycle of the form `GE( (k^r (0|1) k^s) | l^p) )`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">k_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">l_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
    <span class="c1"># if s == 0</span>
    <span class="k">if</span> <span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lemma8</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sig</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">sig</span><span class="p">[</span><span class="mi">3</span><span class="p">:])))</span>
    <span class="c1"># if r == 0</span>
    <span class="k">if</span> <span class="n">sig</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># reverse every individual item before returning it</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lemma8</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sig</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">sig</span><span class="p">[</span><span class="mi">4</span><span class="p">:])))]</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># r &gt; 0</span>
        <span class="n">G</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># induction on r, for every 0 \leq i \leq p</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">lemma9</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sig</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">i</span><span class="p">]))</span>
            <span class="c1"># Initialize recursive_lists with the first item from g</span>
            <span class="n">recursive_lists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="n">l_p</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">],</span> <span class="n">k_r</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
            <span class="c1"># Start the loop from the second item in g</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">recursive_lists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="n">recursive_lists</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">l_p</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">],</span> <span class="n">k_r</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">item</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="c1"># a_i = l^{p-i} k l^i k^{r-1} 01 k^s</span>
            <span class="n">ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">l_p</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">],</span>
                    <span class="n">k_r</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">l_p</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">k_r</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">k_r</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">k_s</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">ai_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">recursive_lists</span> <span class="o">==</span> <span class="n">ai</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># l^{p-i} k l^i k^{r-1} 01 k^s</span>
            <span class="n">aj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">l_p</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_p</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">],</span>
                    <span class="n">k_r</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">l_p</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">k_r</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">k_r</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="n">k_s</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">aj_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">recursive_lists</span> <span class="o">==</span> <span class="n">aj</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># fix the orientation of the list</span>
            <span class="k">if</span> <span class="n">ai_index</span> <span class="o">&gt;</span> <span class="n">aj_index</span><span class="p">:</span>
                <span class="n">recursive_lists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">recursive_lists</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">ai_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">recursive_lists</span> <span class="o">==</span> <span class="n">ai</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">recursive_lists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">recursive_lists</span><span class="p">,</span> <span class="o">-</span><span class="n">ai_index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">G</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">recursive_lists</span><span class="p">)</span>
        <span class="n">G_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="nb">list</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">G</span>
            <span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G_np</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">G_np</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># this will be the first three nodes of the path: (connecting G_0 and G_1)</span>
                <span class="c1"># [l^{p-1} k l k^{r-1} 01 k^s, l^p k^r 01 k^s, l^p k^r 10 k^s, l^{p-1} k l k^{r-1} 10 k^s]</span>
                <span class="n">cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(([</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="c1"># now glue b1 and b2, b3 and b4 etc. and glue a2 and a3, a4 and a5 etc.</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">flipped_item</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">flipped_item</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">flipped_item</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(([</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="k">return</span> <span class="n">cycle</span></div>



<div class="viewcode-block" id="_lemma10_subcycle_cutter">
<a class="viewcode-back" href="../../autoapi/type_variations/stachowiak_numpy/index.html#type_variations.stachowiak_numpy._lemma10_subcycle_cutter">[docs]</a>
<span class="k">def</span> <span class="nf">_lemma10_subcycle_cutter</span><span class="p">(</span>
    <span class="n">cycle</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">gi</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">edge_i</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">edge_j</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cuts the old cycle and gi (to add) to change them for Lemma 10 by Stachowiak.</span>
<span class="sd">    We want to glue the cycle and gi together at the edge_i and edge_j nodes.</span>

<span class="sd">    Args:</span>
<span class="sd">        cycle (np.ndarray): The old cycle to cut for lemma 10.</span>
<span class="sd">        gi (np.ndarray): The subgraph to cut for lemma 10, will be added later.</span>
<span class="sd">        edge_i (np.ndarray):</span>
<span class="sd">            The edge that should be at the start of gi, i.e. position 0 and 1 in `gi`.</span>
<span class="sd">        edge_j (np.ndarray):</span>
<span class="sd">            The edge that should be the point at which the cycle is cut, i.e. position 0 and -1 in `cycle`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[np.ndarray, np.ndarray]:</span>
<span class="sd">            The modified cycle and gi.</span>
<span class="sd">            - The gi starts with edge_i[0] and edge_i[1] is the second node.</span>
<span class="sd">            - The cycle starts with edge_j[0] and edge_j[1] is the last node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ind_node_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">gi</span> <span class="o">==</span> <span class="n">edge_i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># preparing gi so that node_i[0] the first and node_i[1] second in list</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">gi</span><span class="p">[(</span><span class="n">ind_node_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">edge_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">gi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">gi</span><span class="p">[</span><span class="n">ind_node_i</span><span class="p">:],</span> <span class="n">gi</span><span class="p">[:</span><span class="n">ind_node_i</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">gi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ind_node_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">gi</span> <span class="o">==</span> <span class="n">edge_i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">gi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">gi</span><span class="p">,</span> <span class="o">-</span><span class="n">ind_node_i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">ind_node_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">cycle</span> <span class="o">==</span> <span class="n">edge_j</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># preparing the cycle (already glued ones) such that node_j[0] first and node_j[1] last in list</span>
    <span class="k">if</span> <span class="n">ind_node_j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">):</span>
        <span class="c1"># if cycle ends with node_j[0] and ends with node_j[1]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">cycle</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># if cycle ends with node_j[0] and node_j[1] is the second to last element (since they are always neighbors in the path)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># move node_j[0] to the start and append the rest of the cycle</span>
            <span class="n">cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">cycle</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">cycle</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">cycle</span><span class="p">[</span><span class="n">ind_node_j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">edge_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="c1"># if node_j[1] is the second element in the cycle</span>
        <span class="c1"># change cycle to start with node_j[1] and then append the part until node_j[0]. Then reverse the whole cycle</span>
        <span class="n">cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="o">-</span><span class="n">ind_node_j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># otherwise we have [node_j[1], node_j[0], ...] so we move node_j[0] to the start and append the part until node_j[1]</span>
        <span class="n">cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="o">-</span><span class="n">ind_node_j</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">gi</span></div>



<div class="viewcode-block" id="_lemma10_helper">
<a class="viewcode-back" href="../../autoapi/type_variations/stachowiak_numpy/index.html#type_variations.stachowiak_numpy._lemma10_helper">[docs]</a>
<span class="k">def</span> <span class="nf">_lemma10_helper</span><span class="p">(</span><span class="n">K</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">new_color</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function for lemma 10, constructs a cycle by adding color `new_color`, which occurs `p` times, to the graph.</span>

<span class="sd">    Args:</span>
<span class="sd">        K (np.ndarray):</span>
<span class="sd">            A Hamiltonian path in `Q` being `[K_1, K_2, ..., K_2n]`.</span>
<span class="sd">            Every K_i is isomorphic to some `G_i = G(K_{2i-1} | l^p, K_{2i} | l^p)` for `1 &lt;= i &lt;= n`.</span>
<span class="sd">            And every `G_i` is isomorphic to `G_i = G((k^r (0 | 1) k^s) | l^p)`, i.e. the graph from lemma 9.</span>
<span class="sd">        p (int): The length of the last part of the signature (`l^p`)</span>
<span class="sd">        new_color (int): The new color to add to the graph (to transform `l^p`)</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Hamiltonian cycle over `GE(Q | l^p)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># G_i = GE(K_{2i-1} | l^p, K_{2i} | l^p) for 0 &lt;= i &lt;= n</span>
    <span class="n">G</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">l_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">new_color</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
        <span class="c1"># Constructing cycles Ci taking graphs &#39;including&#39; vertices on 2*i and 2*i+1 position</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]):</span>
            <span class="c1"># determining r and s - location of a swap</span>
            <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="n">K</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">2</span>
                <span class="k">break</span>
        <span class="c1"># G_i is isomorphic to GE( (k^r (0|1) k^s) | l^p )</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">lemma9</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">]))</span>

        <span class="n">g_modified</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">remove_color</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
            <span class="n">new_item</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>  <span class="c1"># Convert item to a list</span>
            <span class="c1"># smartly renaming permutations -&gt; isomorphism, depending on order of 01/10 -</span>
            <span class="c1"># tells us either to use 2*2 or 2*i+1</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">new_item</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">new_item</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_item</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">remove_color</span><span class="p">:</span>
                        <span class="n">new_item</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
                        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">it</span> <span class="o">==</span> <span class="n">remove_color</span><span class="p">:</span>
                        <span class="n">new_item</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_color</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_item</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">remove_color</span><span class="p">:</span>
                        <span class="n">new_item</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
                        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">it</span> <span class="o">==</span> <span class="n">remove_color</span><span class="p">:</span>
                        <span class="n">new_item</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_color</span>
            <span class="n">g_modified</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">g_modified</span><span class="p">,</span> <span class="n">new_item</span><span class="p">))</span>  <span class="c1"># adding item to the array</span>
        <span class="n">G</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g_modified</span><span class="p">)</span>  <span class="c1"># adding cycle to the list of G_i&#39;s</span>
    <span class="n">G_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="nb">list</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">])</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">G</span><span class="p">],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">cycle</span> <span class="o">=</span> <span class="n">G_np</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># K_j = k_{j,1} k_{j,2} \dots k_{j,q}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G_np</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># a_i = (l^p k_{2i}, l^{p-1} k_{2i,1} l k{2i,2} \dots k_{2i,q})</span>
        <span class="n">ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">l_p</span><span class="p">,</span> <span class="n">K</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">])),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">l_p</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">K</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="n">l_p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="n">K</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:])),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># b_i = (k_{2i} l^p, k_{2i,1} \dots k_{2i,q-1} l k_{2i,q} l^{p-1})</span>
        <span class="n">bi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">K</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span> <span class="n">l_p</span><span class="p">)),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">K</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">l_p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="p">[</span><span class="n">K</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">l_p</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># a_j = (l^p k_{2i-1}, l^{p-1} k_{2i-1,1} l k_{2i-1,2} \dots, k_{2i-1,q})</span>
        <span class="n">aj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">l_p</span><span class="p">,</span> <span class="n">K</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">l_p</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">K</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="n">l_p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="n">K</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
                <span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># b_j = (k_{2i-1} l^p, k_{2i-1,1} \dots k_{2i-1,q-1} l k_{2i-1,q} l^{p-1})</span>
        <span class="n">bj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">K</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">l_p</span><span class="p">)),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">l_p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="p">[</span><span class="n">K</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">l_p</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># if K_j and K_{j+1} differ in the first pair of elements, a_j and a_{j+1} are parallel</span>
        <span class="k">if</span> <span class="n">adjacent</span><span class="p">(</span><span class="n">ai</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aj</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">adjacent</span><span class="p">(</span><span class="n">ai</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">aj</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">cycle</span><span class="p">,</span> <span class="n">gi</span> <span class="o">=</span> <span class="n">_lemma10_subcycle_cutter</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">gi</span><span class="p">,</span> <span class="n">ai</span><span class="p">,</span> <span class="n">aj</span><span class="p">)</span>
        <span class="c1"># if K_j and K_{j+1} don&#39;t differ in the first pair of elements, b_j and b_{j+1} are parallel</span>
        <span class="k">elif</span> <span class="n">adjacent</span><span class="p">(</span><span class="n">bi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bj</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">adjacent</span><span class="p">(</span><span class="n">bi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bj</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">cycle</span><span class="p">,</span> <span class="n">gi</span> <span class="o">=</span> <span class="n">_lemma10_subcycle_cutter</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">gi</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">bj</span><span class="p">)</span>
        <span class="n">cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">gi</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">gi</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="n">sig_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">sig_list</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">sig_list</span> <span class="o">=</span> <span class="n">sig_list</span><span class="p">[</span><span class="n">sig_list</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">cycle</span></div>



<div class="viewcode-block" id="lemma10">
<a class="viewcode-back" href="../../autoapi/type_variations/stachowiak_numpy/index.html#type_variations.stachowiak_numpy.lemma10">[docs]</a>
<span class="k">def</span> <span class="nf">lemma10</span><span class="p">(</span><span class="n">sig</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes Lemma 10 by Stachowiak:</span>
<span class="sd">    If `q = |Q| &gt; 2`, `Q` is even and `GE(Q)` contains a Hamiltonian path and `p &gt; 0` then `GE(Q|l^p)` has a Hamiltonian cycle.</span>
<span class="sd">    Here `Q` is two elements in the signature that form a Hamiltonian path of even length and p is the third element.</span>

<span class="sd">    Args:</span>
<span class="sd">        sig (np.array):</span>
<span class="sd">            The signature of the graph; `Q` is the first two elements, `p` is the third.</span>
<span class="sd">            `Q` is of length 2, its colors are 0 and 1. It contains a Hamiltonian path.</span>
<span class="sd">            `p` is the third element of sig and has color 2 and occurs `p` times.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray:</span>
<span class="sd">            A Hamiltonian cycle in the neighbor-swap graph of the form `GE(Q|l^p)`</span>

<span class="sd">    Raises:</span>
<span class="sd">        AssertionError:</span>
<span class="sd">            If the signature is not well-formed. The first two elements must be able to form a Hamiltonian path of even length &gt; 2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">HpathNS</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">cycle</span> <span class="o">=</span> <span class="n">_lemma10_helper</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cycle</span></div>



<div class="viewcode-block" id="lemma11">
<a class="viewcode-back" href="../../autoapi/type_variations/stachowiak_numpy/index.html#type_variations.stachowiak_numpy.lemma11">[docs]</a>
<span class="k">def</span> <span class="nf">lemma11</span><span class="p">(</span><span class="n">sig</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds a Hamiltonian cycle in a graph using Lemma 11 from Stachowiak&#39;s paper:</span>
<span class="sd">    If `q = |Q| &gt; 2`, `p = |P| &gt; 0` and `GE(Q)` has an even number of vertices and contains a Hamiltonian path then `GE(Q|P)` has a Hamiltonian cycle.</span>

<span class="sd">    Args:</span>
<span class="sd">        sig (np.array):</span>
<span class="sd">            A signature of a neighbor-swap graph where at least two elements form a Hamiltonian path of even length &gt; 2.</span>
<span class="sd">            These two elements are set to the front of the signature using a recursive call.</span>
<span class="sd">            Note that this can also be three elements if the first two are 1 (using Lemma 2). Or at least 3 elements that occur once (using Steinhaus-Johnson-Trotter algorithm).</span>
<span class="sd">            The rest of the signature is processed using Stachowiak&#39;s lemmas.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray:</span>
<span class="sd">            A Hamiltonian cycle in the neighbor-swap graph of the form `GE(Q|P)`. `Q` is this Hamiltonian path and `P` is the rest of the signature</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the signature is empty.</span>
<span class="sd">        ValueError: There are no elements that can form a Hamiltonian path.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - If `q = |Q| &gt; 2`, `p = |P| &gt; 0` and `GE(Q)` has an even number of vertices and contains a Hamiltonian path, then `GE(Q|P)` has a Hamiltonian cycle.</span>
<span class="sd">        - The function first checks the length of the signature and handles special cases where the signature has only one or two elements.</span>
<span class="sd">        - If the signature is not ordered well, it transforms the signature and recursively calls the function with the transformed signature. The order is well when the first two elements are the largest odd numbers.</span>
<span class="sd">        - If the first two elements in the signature can form a cycle (more than two permutations), it uses Verhoeff&#39;s Theorem to find the cycle.</span>
<span class="sd">        - If the first 3 (or more) elements are 1, it uses the Steinhaus-Johnson-Trotter algorithm to get the Hamiltonian cycle.</span>
<span class="sd">        - If the third element in the signature is not 0, it uses Stachowiak&#39;s Lemma 2 to find a Hamiltonian path in `GE(Q|l^{sig[2]})`.</span>
<span class="sd">        - Finally, it iterates over the remaining elements in the signature and calls the helper function _lemma10_helper to extend the cycle.</span>

<span class="sd">    References:</span>
<span class="sd">        - Stachowiak G. Hamilton Paths in Graphs of Linear Extensions for Unions of Posets. Technical report, 1992</span>
<span class="sd">        - Tom Verhoeff. The spurs of D. H. Lehmer: Hamiltonian paths in neighbor-swap graphs of permutations. Designs, Codes, and Cryptography, 84(1-2):295-310, 7 2017. (Used to find Hamiltonian cycles in binary neighbor-swap graphs.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Signature must have at least one element&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sig</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least two odd numbers are required for Lemma 11&quot;</span><span class="p">)</span>
    <span class="c1"># Index the numbers in the array such that we can transform them back later</span>
    <span class="n">indexed_sig</span> <span class="o">=</span> <span class="p">[(</span><span class="n">value</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sig</span><span class="p">)]</span>

    <span class="c1"># Sort the array based on the function, putting the odd numbers first</span>
    <span class="n">indexed_sig</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

    <span class="c1"># Return the transformed array and the indices</span>
    <span class="n">sorted_sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indexed_sig</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indexed_sig</span><span class="p">])</span>

    <span class="c1"># if the order is well (i.e. the first two elements are the largest odd numbers)</span>
    <span class="c1"># and the number of odd numbers is at least 2</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">sorted_sig</span><span class="p">):</span>
        <span class="c1"># return that solution given by this lemma (transformed, if needed)</span>
        <span class="k">return</span> <span class="n">transform</span><span class="p">(</span><span class="n">lemma11</span><span class="p">(</span><span class="n">sorted_sig</span><span class="p">),</span> <span class="n">indices</span><span class="p">)</span>
    <span class="c1"># if the first two elements in the signature can form a cycle (so more than two permutations)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sig</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">HpathNS</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># K in the paper</span>
        <span class="n">next_color</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sig</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># use the Steinhaus-Johnson-Trotter algorithm to get the Hamiltonian cycle if the first 3 (or more) elements are 1</span>
        <span class="c1"># Check if there are any elements that are not equal to 1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">next_color</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Return the first index that is not 1</span>
            <span class="n">next_color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">sig</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">SteinhausJohnsonTrotterNumpy</span><span class="o">.</span><span class="n">get_sjt_permutations</span><span class="p">(</span>
            <span class="n">SteinhausJohnsonTrotterNumpy</span><span class="p">(),</span> <span class="n">next_color</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># use Stachowiak&#39;s lemma 2 to find a Hamiltonian path in GE(Q|P[1])</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">lemma2_extended_path</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">next_color</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;q = |Q| &gt; 2 and GE(Q) has an even number of vertices is required for Lemma 11&quot;</span>
        <span class="p">)</span>
    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">new_color</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">next_color</span><span class="p">:],</span> <span class="n">start</span><span class="o">=</span><span class="n">next_color</span><span class="p">):</span>
        <span class="n">cycle</span> <span class="o">=</span> <span class="n">_lemma10_helper</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">new_color</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">cycle</span>
    <span class="k">return</span> <span class="n">path</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Max Opperman.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>