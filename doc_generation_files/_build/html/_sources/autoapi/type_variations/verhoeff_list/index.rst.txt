type_variations.verhoeff_list
=============================

.. py:module:: type_variations.verhoeff_list


Functions
---------

.. autoapisummary::

   type_variations.verhoeff_list.stutterize
   type_variations.verhoeff_list.selectOdds
   type_variations.verhoeff_list.stutterPermutations
   type_variations.verhoeff_list.createZigZagPath
   type_variations.verhoeff_list.incorporateSpurInZigZag
   type_variations.verhoeff_list.incorporateSpursInZigZag
   type_variations.verhoeff_list.createSquareTube
   type_variations.verhoeff_list.swapPair
   type_variations.verhoeff_list.extend
   type_variations.verhoeff_list.HpathNS


Module Contents
---------------

.. py:function:: stutterize(p: list[int]) -> list[list[int]]

   Converts argument into a stutter permutation by repeating every number.
   :param p: permutation as a list of integers
   :type p: list[int]

   :returns: every number in p repeated twice and put into a list


.. py:function:: selectOdds(sig: list[int]) -> list[int]

   Returns list of numbers with odd occurrence frequencies in the given signature.
   :param sig: signature as a list of integers
   :type sig: list[int]

   :returns: list of integers with odd occurrence frequencies in the signature


.. py:function:: stutterPermutations(s: list[int]) -> list[list[int]]

   Generates stutter permutations of a given signature.
   Stutter permutations have the form [a, a, b, b, c, c, ..., z] where a, b, c, ... are the elements of the permutation.
   So every pair of elements is repeated twice from the left. An stutter can have one element with odd frequency appended at the end.
   :param s: the signature of the stutter permutations
   :type s: list[int]

   :returns: list of stutter permutations of signature `s`


.. py:function:: createZigZagPath(c: list[list[int]], u: list[int], v: list[int]) -> list[list[int]]

   :param c: cycle of even length, list of tuples
   :param u: tuple to append
   :param v: tuple to append
   :return: cycle obtained by combining two "parallel" copies of given cycle, to form a 'square wave',
           running from cycle[[1]]v to cycle[[-1]]v; the two copies are distinguished by
           appending u and v; also works for a path


.. py:function:: incorporateSpurInZigZag(path: list[list[int]], vertex_pair: list[list[int]]) -> list[list[int]]

.. py:function:: incorporateSpursInZigZag(path: list[list[int]], vertices: list[list[int]], spur_suffixes: list[list[int]]) -> list[list[int]]

.. py:function:: createSquareTube(path: list[list[int]], u: list[int], v: list[int]) -> list[list[int]]

.. py:function:: swapPair(perm: list[int], i: int, j=None) -> list[int]

   Swaps elements in perm at positions i and j (or i and i+1 if j is not provided).


.. py:function:: extend(lst: list[list[int]], e: list[int]) -> list[list[int]]

   Extend every item in l with e
   :param lst: list of lists of integers
   :param e: list to extend every item in l with
   :return:


.. py:function:: HpathNS(k0: int, k1: int) -> list[list[int]]

   Computes a Hamiltonian path in the neighbor-swap graph on the non-stutter permutations for the given signature.
   If k0 and k1 are both even, the path is a Hamiltonian cycle.
   :param k0: Number of 0s in the signature.
   :type k0: int
   :param k1: Number of 1s in the signature.
   :type k1: int

   :returns: A Hamiltonian path in the neighbor-swap graph G(0^k_0|1^(k_1)).
   :rtype: list[list[int]]

   .. rubric:: References

   - Tom Verhoeff. The spurs of D. H. Lehmer: Hamiltonian paths in neighbor-swap graphs of permutations. Designs, Codes, and Cryptography, 84(1-2):295-310, 7 2017.


