from bisect import bisect, insort
from heapq import heappop, heappush
from itertools import permutations as itertoolspermutations

from helper_operations.path_operations import adjacent, pathQ


def binomial(k0: int, k1: int) -> int:
    """Returns binomial coefficient k0+k1 choose k0, which equals k0+k1 choose k1.
    Assumption: 0 <= k0 and 0 <= k1
    """
    assert k0 >= 0 and k1 >= 0
    if k0 == 0:
        return 1
    elif k1 < k0:
        return binomial(k1, k0)
    else:
        k = k1 + 1
        return (binomial(k0 - 1, k) * k) // k0


def multinomial(s: list[int]) -> int:
    """Returns multinomial coefficient for list s.
    Assumption: all(0 <= k for k in s)"""
    assert all(0 <= k for k in s)
    if len(s) <= 1:
        return 1
    t = sorted(s)
    k0, k1 = t[0], t[1]
    t[1] = k0 + k1
    return binomial(k0, k1) * multinomial(t[1:])


def perm(sig: list[int]) -> list[list[int]]:
    """
    Returns all permutations with signature sig
    @param sig: signature as a list of integers
    @return: list of permutations as lists of integers
    """
    first_perm = []
    for index, item in enumerate(sig):
        first_perm.extend([index] * item)

    return [list(p) for p in set(itertoolspermutations(first_perm))]


def get_num_of_inversions(permutation: tuple[int, ...]) -> int:
    """
    Count the number of inversions in a permutation using merge sort
    From https://www.geeksforgeeks.org/inversion-count-in-array-using-merge-sort/
    @param permutation: list of integers
    @return: number of inversions
    """
    if len(permutation) <= 1:
        return 0
    sortList = []
    result = 0
    # Heapsort, O(N*log(N))
    for i, v in enumerate(permutation):
        heappush(sortList, (v, i))
    # Create a sorted list of indexes
    x = []
    while sortList:
        # O(log(N))
        v, i = heappop(sortList)
        # Find the current minimum's index
        # the index y can represent how many minimums on the left
        y = bisect(x, i)
        # i can represent how many elements on the left
        # i - y can find how many bigger nums on the left
        result += i - y

        insort(x, i)

    return result


def count_inversions(sig: list[int]) -> dict[tuple, int]:
    """
    Count the number of inversions for all permutations of a signature
    @param sig: signature as a list of integers
    @return: dictionary with permutations as keys and number of inversions as values
    """
    if len(sig) == 0:
        return dict()
    return {tuple(i): get_num_of_inversions(i) for i in perm(sig)}


def defect(s: list[int]) -> int:
    """
    Returns the number of spurs of a given signature according to Lehmer's definition for the defect:
    The number of even permutations - number of odd permutations
    @param s: signature as a list of integers
    @return: absolute difference between the number of even and odd permutations
    """
    if len(s) < 2:
        return 0
    inv_dict = count_inversions(s)
    even_count = sum(1 for value in inv_dict.values() if value % 2 == 0)
    return abs(even_count - (len(inv_dict) - even_count))


def swapPair(perm: tuple[int, ...], i: int, j: int = None) -> tuple[int, ...]:
    """
    Swaps elements in perm at positions i and j (or i and i+1 if j is not provided).
    @param perm: permutation as a tuple of integers
    @param i: first index
    @param j: second index (optional, default is i+1)
    @return: new permutation as a tuple of integers
    """
    perm = list(perm)
    if j is None:
        j = i + 1
    if i > len(perm) - 1 or j > len(perm) - 1:
        raise ValueError(f"Index {i} out of range for permutation {perm}")
    if i < len(perm) and j < len(perm):
        perm[i], perm[j] = perm[j], perm[i]
    return tuple(perm)


def generate_adj(p: list[int]) -> list[tuple[int, ...]]:
    """
    Returns all adjacent elements of permutation p
    @param p: list of integers
    @return: list of tuples of integers, the new permutations generated by neighbor-swapping
    """
    v = []
    for i, item in enumerate(p):
        if i + 1 < len(p) and item != p[i + 1]:
            v.append(swapPair(p, i))
    return v


def graph(sig: list[int]) -> dict[str, set[str]]:
    """
    Returns a graph with signature sig in form of dictionary of strings
    @param sig: signature as a list of integers
    @return: dictionary with permutations as keys and adjacent permutations as values
    """
    if len(sig) == 0:
        return dict()
    p = perm(sig)

    dic = {}
    for i in p:
        dic["".join(map(str, i))] = set(
            ["".join(map(str, el)) for el in generate_adj(i)]
        )
    return dic


def extend(lst: list[tuple[int, ...]], e: tuple[int, ...]) -> list[tuple[int, ...]]:
    """
    Extend every item in l with e
    :param lst: list of tuples
    :param e: tuple to extend every item in l with
    :return:
    """
    return [i + e for i in lst]


def extend_cycle_cover(
    lis3d: list[list[tuple[int, ...]]], e: tuple[int, ...]
) -> list[list[tuple[int, ...]]]:
    """
    Extend every item in a list of unknown depth holding a list of permutations with e
    :param lst: list of unknown depth with list of tuples
    :param e: tuple to extend every item in l with
    :return:
    """
    assert len(lis3d) > 0
    if isinstance(lis3d[0][0][0], int):
        return [extend(l, e) for l in lis3d]
    elif not isinstance(lis3d, list):
        raise ValueError("The input is not a list")
    else:
        return [extend_cycle_cover(l, e) for l in lis3d]


def shorten(lis: list[tuple[int, ...]], num: int) -> list[tuple[int, ...]]:
    """
    Shorten every item in l by num elements from the end
    @param lis: list of permutations
    @param num: number of elements to remove from the back
    @return: list of shortened permutations
    """
    assert len(lis) > 0
    assert all(len(i) >= num for i in lis)
    if num == 0:
        return lis
    if num < 0:
        return [i[-num:] for i in lis]
    return [i[:-num] for i in lis]


def signature(permutation: tuple[int, ...]) -> list[int]:
    """
    Returns signature of a permutation.
    @param permutation: permutation as a tuple of integers
    @return: signature as a list of integers
    """
    if not permutation:
        return []
    return [permutation.count(i) for i in range(max(permutation) + 1)]


def rotate(l: list, n: int) -> list:
    """
    Rotates the list l by n positions to the left
    @param l: list to rotate
    @param n: number of positions to rotate
    """
    if len(l) <= 1:
        return l
    return l[n % len(l) :] + l[: n % len(l)]


def _halveSignature(sig: list[int]) -> list[int]:
    """
    Halves the signature. ([2, 4, 6] --> [1, 2, 3]), rounding down.
    @param sig: signature as a list of integers
    @return: halved signature as a list of integers
    """
    if any(i < 0 for i in sig):
        raise ValueError("Signature must be a list of non-negative integers.")
    return [i // 2 for i in sig]


def multiset(s: list[int]) -> tuple[int, ...]:
    """
    Generates the lexicographically smallest list with given signature.
    @param s: list of integers, each representing the frequency of the corresponding element (signature)
    @return: lexicographically smallest permutation with the given signature
    """
    if isinstance(s, int):
        s = [s]
    if not all(i >= 0 for i in s):
        raise ValueError("Signature must be a list of non-negative integers.")
    return tuple([i for i, f in enumerate(s) for _ in range(f)])


def _permutations(s: list[int]) -> list[tuple[int, ...]]:
    """
    Generates all possible permutations of a given list of integers.
    @param s: list of integers, the signature
    @return: list of permutations as tuples of integers
    """
    if isinstance(s, int):
        s = [s]
    if len(s) == 0:
        return []
    # for itertools permutations:
    # Elements are treated as unique based on their position, not on their value.
    return list(set(itertoolspermutations(multiset(s))))


def _selectOdds(sig: tuple[int, ...]) -> tuple[int, ...]:
    """
    Returns list of numbers with odd occurrence frequencies in the given signature.
    @param sig: signature as a tuple of integers
    @return: tuple of integers with odd occurrence frequencies
    """
    return tuple([i for i, item in enumerate(sig) if item % 2 == 1])


def stutterPermutations(s: list[int]) -> list[tuple[int, ...]]:
    """
    Generates stutter permutations of a given signature.
    @param s: signature of the permutations as a list of integers
    @return: stutter permutations as a list of tuples of integers
    """
    odds = _selectOdds(s)
    if len(odds) >= 2 or len(s) == 0 or (len(s) == 1 and s[0] == 0):
        return []
    else:
        result = _stutterize(_permutations(_halveSignature(s)))
        if len(odds) == 1:
            return extend(result, odds)
        else:
            return result


def nonStutterPermutations(s: list[int]) -> list[tuple[int, ...]]:
    """
    Returns all non-stutter permutations of signature sig
    @param sig: signature of the permutations as a list of integers
    @return: non-stutter permutations as a list of tuples of integers
    """
    if len(s) == 0 or (len(s) == 1 and s[0] == 0):
        return []
    return [tuple(p) for p in perm(s) if not tuple(p) in stutterPermutations(s)]


def _stutterize(p_list: list[tuple[int, ...]]) -> list[tuple[int, ...]]:
    """
    Converts a list of permutations into stutter permutation by repeating every number twice
    @param p: a list of permutations as a list of tuples of integers
    @return: all stutter permutations as a list of tuples of integers
    """
    return [tuple([el for el in t for _ in range(2)]) for t in p_list]


def selectByTail(
    permutations: list[tuple[int, ...]], tail: tuple[int, ...]
) -> list[tuple[int, ...]]:
    """
    Select permutations with a given tail 'tail'
    @param s: list of permutations
    @param tail: elements of the tail to select
    @return: list of permutations with the given tail
    """
    return [i for i in permutations if i[-len(tail) :] == tail]


def HpathQ(per: list[tuple[int, ...]], sig: list[int]) -> bool:
    """
    Determines whether the path is a Hamiltonian path on the non-stutter permutations of the given signature.
    @param per: list of permutations ordered in a path
    @param sig: signature as a list of integers
    """
    if pathQ(per):
        return set(per) == set(nonStutterPermutations(sig))
    return False


def HcycleQ(per: list[tuple[int, ...]], sig: list[int]) -> bool:
    """
    Determines whether the path is a Hamiltonian cycle on the non-stutter permutations of the given signature.
    @param per: list of permutations, ordered in a cycle
    @param sig: signature as a list of integers
    """
    if len(per) <= 2:
        return False
    return adjacent(per[0], per[-1]) and HpathQ(per, sig)


def total_path_motion(path: list[tuple[int, ...]]) -> int:
    """
    Returns the sum of the transposition widths (difference in index between the two transposed elements) for all nodes in the path
    @param path: list of permutations
    @return: total motion as an integer
    """
    total_motion = 0
    for node in range(len(path) - 1):
        permutation_a = path[node]
        permutation_b = path[node + 1]
        for i in range(len(permutation_a)):
            if permutation_a[i] != permutation_b[i]:
                for j in range(i, len(permutation_a)):
                    if permutation_a[j] != permutation_b[j]:
                        width = abs(i - j)
                        if width > 2:
                            print(
                                f"Width of transposition {node} is {width}: {permutation_a}, {permutation_b}"
                            )
                        total_motion += width
    return total_motion
