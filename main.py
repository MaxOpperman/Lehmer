from itertools import permutations, combinations
import math
from collections import Counter
from functools import reduce

import networkx as nx
import matplotlib.pyplot as plt


def visualize(perm_inversions):
    graph = nx.Graph()
    partite_counts = dict.fromkeys(set(perm_inversions.values()), 0)

    for node, k_partite in perm_inversions.items():
        graph.add_node(node, pos=(k_partite, partite_counts[k_partite]))
        partite_counts[k_partite] += 1

        # Add edges between permutations that can be transformed into each other by a single neighbor swap
    permutations = list(perm_inversions.keys())
    highlight_edge = True
    for i in range(len(permutations)):
        for j in range(i + 1, len(permutations)):
            perm1, perm2 = permutations[i], permutations[j]
            inv_diff = abs(perm_inversions[perm1] - perm_inversions[perm2])
            if inv_diff == 1 and can_neighbor_swap(perm1, perm2):
                graph.add_edge(perm1, perm2, color=('r' if highlight_edge else 'b'))
                highlight_edge = not highlight_edge

    plt.figure(figsize=(19, 38))
    pos = nx.get_node_attributes(graph, 'pos')
    # also add edge_colors=colors to nx.draw
    # colors = [graph[u][v]['color'] for u, v in graph.edges]
    nx.draw(graph, pos, with_labels=True)

    plt.axis('off')
    plt.show()


def can_neighbor_swap(perm1, perm2):
    """
    Check if two permutations can be transformed into each other by a single neighbor swap.
    """
    index = 0
    neighbor_swaps = 0
    while index < len(perm1) - 1:
        if perm1[index] != perm2[index]:
            if perm1[index+1] != perm2[index+1] and perm1[index] == perm2[index+1] and perm2[index] == perm1[index+1]:
                neighbor_swaps += 1
                index += 1
            else:
                return False
        index += 1
    return neighbor_swaps == 1


def compute_parity(perms):
    """
    Compute the parity of the number of inversions for each permutation in a list.
    """
    parity_dict = {}
    even_count, odd_count = 0, 0
    for perm in perms:
        inv = count_inversions(perm)
        parity_dict[perm] = inv
        if inv % 2 == 0:
            even_count += 1
        else:
            odd_count += 1
    return parity_dict, even_count, odd_count


def count_inversions(perm):
    """
    Count the number of inversions in a permutation.
    """
    inversions = 0
    for i in range(len(perm)):
        for j in range(i + 1, len(perm)):
            if perm[i] > perm[j]:
                inversions += 1
    return inversions


def count_permutations(inp):
    # Count occurrences of each character
    char_counts = Counter(inp)

    # Calculate factorial of counts and multiply them together
    total_factorial = reduce(lambda x, y: x * y, (math.factorial(count) for count in char_counts.values()), 1)

    return math.factorial(len(inp))/total_factorial


def print_unique_permutations(input_str):
    # Generate all permutations of the input string
    perm = permutations(input_str)

    # Use a set to store unique permutations
    unique_permutations_set = set()

    # Use a list to store the order of generated permutations
    unique_permutations_list = []

    # Iterate over all permutations
    for p in perm:
        perm_str = ''.join(p)
        # Check if the permutation has not been printed before
        if perm_str not in unique_permutations_set:
            unique_permutations_set.add(perm_str)
            unique_permutations_list.append(perm_str)
    return unique_permutations_list


# Press the green button in the gutter to run the script.
if __name__ == '__main__':
    # Test the function
    input_string = input("Provide a permutation: ")
    print(
        "Number of permutations",
        count_permutations(input_string),
        "generated by '{}' are:".format(input_string),
    )
    permutations = print_unique_permutations(input_string)
    parities, even, odd = compute_parity(permutations)
    # Print each unique permutation in the order they were generated
    print("Computed all {} permutations of which {} are even and {} odd".format(len(parities), even, odd))
    visualize(parities)

